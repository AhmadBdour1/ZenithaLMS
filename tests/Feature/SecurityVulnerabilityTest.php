<?php

namespace Tests\Feature;

use Tests\TestCase;
use App\Models\User;
use App\Models\Quiz;
use App\Models\Ebook;
use App\Models\Forum;
use App\Models\Course;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;

class SecurityVulnerabilityTest extends TestCase
{
    use RefreshDatabase, WithFaker;

    /** @test */
    public function xss_is_prevented_in_virtual_class_description()
    {
        $maliciousScript = '<script>alert("XSS")</script>';
        
        // Test that XSS is properly escaped in the virtual class show page
        $response = $this->get('/zenithalms/virtual-class/show');
        
        // The page should load without executing malicious scripts
        $response->assertStatus(200);
        
        // If there was a virtual class with malicious content, it should be escaped
        // This test ensures the template uses {{ }} instead of {!! !!}
    }

    /** @test */
    public function mass_assignment_is_prevented_in_quiz_update()
    {
        $user = User::factory()->create();
        $instructor = User::factory()->create(['role' => 'instructor']);
        $course = Course::factory()->create(['instructor_id' => $instructor->id]);
        $quiz = Quiz::factory()->create([
            'course_id' => $course->id,
            'created_by' => $instructor->id
        ]);
        
        // Attempt to update quiz with malicious data
        $response = $this->actingAs($user)
            ->putJson("/api/v1/quizzes/{$quiz->id}", [
                'title' => 'New Title',
                'is_admin' => true,  // Should be ignored
                'role' => 'admin',  // Should be ignored
                'user_id' => 999,   // Should be ignored
            ]);
        
        // Unauthorized user should be denied
        $response->assertStatus(403);
        
        // Verify the quiz wasn't updated with malicious data
        $this->assertNotEquals('New Title', $quiz->fresh()->title);
        $this->assertFalse($user->fresh()->is_admin);
    }

    /** @test */
    public function authorized_user_can_update_quiz_with_valid_data()
    {
        $instructor = User::factory()->create(['role' => 'instructor']);
        $course = Course::factory()->create(['instructor_id' => $instructor->id]);
        $quiz = Quiz::factory()->create([
            'course_id' => $course->id,
            'created_by' => $instructor->id
        ]);
        
        $response = $this->actingAs($instructor)
            ->putJson("/api/v1/quizzes/{$quiz->id}", [
                'title' => 'Updated Title',
                'description' => 'Updated Description',
                'duration_minutes' => 60,
                'passing_score' => 80,
            ]);
        
        $response->assertStatus(200);
        $this->assertEquals('Updated Title', $quiz->fresh()->title);
    }

    /** @test */
    public function mass_assignment_is_prevented_in_forum_update()
    {
        $user = User::factory()->create();
        $forumUser = User::factory()->create();
        $forum = Forum::factory()->create(['user_id' => $forumUser->id]);
        
        // Attempt to update forum with malicious data
        $response = $this->actingAs($user)
            ->putJson("/api/v1/forums/{$forum->id}", [
                'title' => 'Hacked Title',
                'is_admin' => true,  // Should be ignored
                'user_id' => 999,    // Should be ignored
            ]);
        
        $response->assertStatus(403);
        
        // Verify the forum wasn't updated
        $this->assertNotEquals('Hacked Title', $forum->fresh()->title);
    }

    /** @test */
    public function mass_assignment_is_prevented_in_ebook_update()
    {
        $user = User::factory()->create();
        $author = User::factory()->create();
        $ebook = Ebook::factory()->create(['user_id' => $author->id]);
        
        // Attempt to update ebook with malicious data
        $response = $this->actingAs($user)
            ->putJson("/api/v1/ebooks/{$ebook->id}", [
                'title' => 'Hacked Ebook',
                'is_admin' => true,  // Should be ignored
                'user_id' => 999,    // Should be ignored
                'price' => -100,     // Should be validated
            ]);
        
        $response->assertStatus(403);
        
        // Verify the ebook wasn't updated
        $this->assertNotEquals('Hacked Ebook', $ebook->fresh()->title);
    }

    /** @test */
    public function financial_endpoints_have_rate_limiting()
    {
        $user = User::factory()->create();
        
        // Make multiple requests to a financial endpoint
        $responses = [];
        for ($i = 0; $i < 15; $i++) {
            $responses[] = $this->actingAs($user)
                ->postJson('/api/v1/payments/process', [
                    'course_id' => 1,
                    'payment_method' => 'test',
                    'payment_details' => ['test' => 'data'],
                ]);
        }
        
        // The last request should be rate limited
        $this->assertEquals(429, $responses[14]->status());
    }

    /** @test */
    public function sanctum_tokens_expire()
    {
        $user = User::factory()->create();
        
        // Create a token
        $token = $user->createToken('test-token');
        
        // Verify the token has an expiration date
        $this->assertNotNull($token->accessToken->expires_at);
        
        // Verify expiration is set correctly (30 days from creation)
        $expectedExpiration = now()->addDays(30);
        $actualExpiration = $token->accessToken->expires_at;
        
        // Allow for small time differences
        $this->assertLessThan(60, $expectedExpiration->diffInMinutes($actualExpiration));
    }

    /** @test */
    public function stripe_webhook_signature_verification_is_enhanced()
    {
        // Test that webhook signature verification is properly implemented
        $payload = json_encode(['test' => 'data']);
        $signature = 'invalid_signature';
        
        $response = $this->postJson('/api/webhooks/stripe', $payload, [
            'Stripe-Signature' => $signature
        ]);
        
        // Should return 400 for invalid signature
        $response->assertStatus(400);
        $response->assertJson([
            'success' => false,
            'message' => 'Invalid webhook signature'
        ]);
    }

    /** @test */
    public function api_endpoints_require_authentication()
    {
        // Test that protected endpoints require authentication
        $protectedEndpoints = [
            '/api/v1/quizzes',
            '/api/v1/forums',
            '/api/v1/ebooks',
            '/api/v1/payments',
        ];
        
        foreach ($protectedEndpoints as $endpoint) {
            $response = $this->getJson($endpoint);
            $response->assertStatus(401);
        }
    }

    /** @test */
    public function input_validation_works_correctly()
    {
        $user = User::factory()->create();
        
        // Test quiz creation with invalid data
        $response = $this->actingAs($user)
            ->postJson('/api/v1/quizzes', [
                'title' => '',  // Empty title should fail validation
                'description' => str_repeat('a', 1000),  // Too long
                'duration_minutes' => -1,  // Negative value
                'passing_score' => 150,  // Over 100
            ]);
        
        $response->assertStatus(422);
        $response->assertJsonValidationErrors(['title', 'duration_minutes', 'passing_score']);
    }

    /** @test */
    public function sensitive_operations_require_proper_authorization()
    {
        $user = User::factory()->create();
        $instructor = User::factory()->create(['role' => 'instructor']);
        $course = Course::factory()->create(['instructor_id' => $instructor->id]);
        $quiz = Quiz::factory()->create([
            'course_id' => $course->id,
            'created_by' => $instructor->id
        ]);
        
        // Test that regular user cannot delete instructor's quiz
        $response = $this->actingAs($user)
            ->deleteJson("/api/v1/quizzes/{$quiz->id}");
        
        $response->assertStatus(403);
        
        // Test that instructor can delete their own quiz
        $response = $this->actingAs($instructor)
            ->deleteJson("/api/v1/quizzes/{$quiz->id}");
        
        $response->assertStatus(200);
    }

    /** @test */
    public function csrf_protection_is_enabled()
    {
        // Test that CSRF protection is enabled for stateful requests
        $response = $this->post('/login', [
            'email' => 'test@example.com',
            'password' => 'password',
        ]);
        
        // Should fail without CSRF token for web routes
        $this->assertContains('419', $response->getStatusCode() == 419 ? ['419'] : []);
    }

    /** @test */
    public function secure_headers_are_present()
    {
        $response = $this->get('/');
        
        // Check for security headers
        $response->assertHeader('X-Frame-Options');
        $response->assertHeader('X-Content-Type-Options');
        $response->assertHeader('X-XSS-Protection');
    }

    /** @test */
    public function error_messages_do_not_expose_sensitive_information()
    {
        // Test that error messages don't expose sensitive system information
        $response = $this->getJson('/api/v1/nonexistent-endpoint');
        
        $response->assertStatus(404);
        
        // Should not contain sensitive information like file paths
        $responseContent = $response->getContent();
        $this->assertStringNotContainsString('stack trace', strtolower($responseContent));
        $this->assertStringNotContainsString('app/', strtolower($responseContent));
    }

    /** @test */
    public function file_uploads_are_validated()
    {
        $user = User::factory()->create();
        
        // Test file upload validation
        $response = $this->actingAs($user)
            ->postJson('/api/v1/upload', [
                'file' => 'invalid_file_data',
                'type' => 'avatar'
            ]);
        
        // Should validate file properly
        $response->assertStatus(422);
    }

    /** @test */
    public function database_queries_are_parameterized()
    {
        // This test ensures we're using proper parameter binding
        // by checking that potentially malicious input doesn't cause SQL errors
        
        $user = User::factory()->create();
        $maliciousInput = "'; DROP TABLE users; --";
        
        // Try to search with malicious input
        $response = $this->actingAs($user)
            ->getJson("/api/v1/courses?search={$maliciousInput}");
        
        // Should not cause database errors
        $response->assertStatus(200);
        
        // Users table should still exist
        $this->assertDatabaseCount('users', 1);
    }

    /** @test */
    public function session_management_is_secure()
    {
        $user = User::factory()->create();
        
        // Log in
        $response = $this->post('/login', [
            'email' => $user->email,
            'password' => 'password',
        ]);
        
        $response->assertRedirect('/');
        
        // Verify session is secure
        $this->assertAuthenticatedAs($user);
        
        // Session should be invalidated on logout
        $this->post('/logout');
        $this->assertGuest();
    }
}
